<html>
    <head>
        <meta content="width=device-width, initial-scale=1.0" name="viewport">
        <meta content="Heman Gandhi" name="author">
        <meta content= "I'm Heman Gandhi, and here's a traditional Indian timing (Choghadiya) calculator." name="description">
        <meta content=
        "Heman Gandhi, Interactive Resume, programmer, Web developer, Full Stack Developer, Interactive CV, Resume, CV, Algorithms, Programming, Choghadiya, Murat" name="keywords">
        <title>Choghadiya</title>

        <style>
.good-murat {
    color: green;
}

.bad-murat {
    color: red;
}
        </style>
    </head>
    <body>
        <h2>Choghadiya Calculator</h2>
        <label for="initial-date">Date:</label>
        <input id="initial-date" type="date"></input>
        <table border="1">
            <thead>
                <tr>
                    <th>City</th>
                    <th>Sunrise</th>
                    <th>Sunset</th>
                    <th>Timezone</th>
                    <th>Choghadiya</th>
                </tr>
            </thead>
            <tbody id="cities">
            </tbody>
        </table>
        <button id="add-city">Add city</button>
        <button id="share-button">Copy shareable link</button>
        <table border="1">
            <thead>
                <tr>
                    <th>City</th>
                    <th>Overlapping good times</th>
                </tr>
            </thead>
            <tbody id="overlaps">
            </tbody>
        </table>
        <div>
            See <a href="#choghadiya-desc">below for a brief explanation of the system</a>. To use this page:
            <ol>
                <li>Enter a date above.</li>
                <li>Enter a name for the first city.</li>
                <li>Enter the sunrise time at the date you entered.</li>
                <li>
                    Enter the sunset time at the date you entered.
                    <ol>
                        <li>At this point, the "choghadiya" column for the city should have the murats and times for the given day in the city's local time. Good Murats are colored <span style="color:green">green</span> and bad ones are colored <span style="color:red">red</span>.</li>
                    </ol>
                </li>

                <li>Enter the timezone for the city (on the provided date).</li>
                <li>Add as many cities as you need and repeat steps 2 through 5 for each.</li>
                <li>Refer to the "overlapping good times" below to see all the times that are auspicious in every city. Here too, each time is in the city's local time.</li>
                <li>
                    Copy the shareable link to the page.
                    <ol>
                        <li>After you copy, you can also use the browser's back button to reach the state of the page when you copied.</li>
                    </ol>
                </li>
            </ol>
        </div>
        <div id="choghadiya-desc">
            <h3>What is Choghadiya?</h3>
            The Choghadiya system is a traditional Indian time-keeping system, where days start from sunrise to sunset and nights start
            at sunset and end on the next sunrise.<br/>
            Both day and night are divided into 8 "hours" that are called Choghadiya, and the hour and weekday determines a
            "Murat", which can be considered good or bad. <a href="https://www.drikpanchang.com/tutorials/muhurat/daily/choghadiya-muhurat.html" target="_blank">Here's another site that has more details on the system.</a><br/>
            This page helps coordinate religious ceremonies across timezones, but note that:
            <ul>
                <li>Sunrise and sunset times can vary within a timezone -- even within similar latitudes (compare Tokyo and Seoul, for example).</li>
                <li>Since the "solar day" starts at sunrise, some suggested times are past midnight. The times from midnight to the next sunrise are considered as being in the previous day (by this calculator, no idea what Hinduism wants).</li>
                <li>This calculator assumes that the next sunrise is "close enough" to the previous one, so doesn't account for its actual drift. (For Diwali calculations in the Northern hemisphere, this means that the night murats are slightly longer than they should be.)</li>
            </ul>
        </div>
        <script>
const CHOGHADIYA_TABLE = [
    ["Udveg", "Chal", "Laabh", "Amrut", "Kaal", "Shubh", "Rog", "Udveg", "Shubh", "Amrut", "Chal", "Rog", "Kaal", "Laabh", "Udveg", "Shubh"],
    ["Amrut", "Kaal", "Shubh", "Rog", "Udveg", "Chal", "Laabh", "Amrut", "Chal", "Rog", "Kaal", "Laabh", "Udveg", "Shubh", "Amrut", "Chal"],
    ["Rog", "Udveg", "Chal", "Laabh", "Amrut", "Kaal", "Shubh", "Rog", "Kaal", "Laabh", "Udveg", "Shubh", "Amrut", "Chal", "Rog", "Kaal"],
    ["Laabh", "Amrut", "Kaal", "Shubh", "Rog", "Udveg", "Chal", "Laabh", "Udveg", "Shubh", "Amrut", "Chal", "Rog", "Kaal", "Laabh", "Udveg"],
    ["Shubh", "Rog", "Udveg", "Chal", "Laabh", "Amrut", "Kaal", "Shubh", "Amrut", "Chal", "Rog", "Kaal", "Laabh", "Udveg", "Shubh", "Amrut"],
    ["Chal", "Laabh", "Amrut", "Kaal", "Shubh", "Rog", "Udveg", "Chal", "Rog", "Kaal", "Laabh", "Udveg", "Shubh", "Amrut", "Chal", "Rog"],
    ["Kaal", "Shubh", "Rog", "Udveg", "Chal", "Laabh", "Amrut", "Kaal", "Laabh", "Udveg", "Shubh", "Amrut", "Chal", "Rog", "Kaal", "Laabh"]
];
const GOOD_MURATS = ["Amrut", "Shubh", "Chal", "Laabh"];

let city_count = 0;
let city_times_map = new Object();
let city_update_handlers = [];

function resetCopyButton() {
    document.getElementById("share-button").innerText = "Copy shareable link";
}

function getDateAndChoghadiyaRow() {
    let date_value = document.getElementById("initial-date").value;
    if (!date_value) return null;
    let [year, month, day] = date_value.split("-").map((t) => parseInt(t));
    // The string month is 1-indexed, the parameter to the date function is 0-indexed.
    month--;
    let day_index = new Date(year, month, day).getDay();
    return [year, month, day, CHOGHADIYA_TABLE[day_index]];
}

function utcTimeToString(utc) {
    let d = new Date(utc);
    return `${d.getUTCHours()}:${d.getUTCMinutes().toString().padStart(2, "0")}`;
}

function makeIntervalHighlighter(interval_id, color) {
    return function () {
        const intervals = document.getElementsByClassName(`overlap-interval-${interval_id}`);
        for (let i = 0; i < intervals.length; i++) {
            intervals[i].style.background = color;
        }
    };
}

function computeContiguousGoodMurats(choghadiya_row) {
    let good_times = [];
    let good_interval_start = -1;
    for (let i = 0; i < 16; i++) {
        let is_good_murat = GOOD_MURATS.indexOf(choghadiya_row[i]) >= 0;
        if (is_good_murat && good_interval_start < 0) {
            good_interval_start = i;
        } else if (!is_good_murat && good_interval_start >= 0) {
            good_times.push([good_interval_start, i]);
            good_interval_start = -1;
        }
    }
    if (good_interval_start >= 0) {
        good_times.push([good_interval_start, 16]);
    }
    return good_times;
}

function getCityOffsetsAndOverlapInputs(good_times) {
    let city_offsets = new Object();
    let overlaps_inputs = new Object();
    let last_start_time = -1;
    let first_end_time = -1;
    for (let i = 0; i < city_count; i++) {
        let city_times = city_times_map[i];
        if (!city_times) {
            document.getElementById(`overlap-${i}-data`).innerText = "Please input data for this city!";
            continue;
        }
        let timezone = document.getElementById(`city-${i}-timezone`).value;
        if (!timezone) {
            document.getElementById(`overlap-${i}-data`).innerText = "Please input the timezone for this city!";
            continue;
        }
        let tz_offset = timezone * 60 * 60 * 1000;
        city_offsets[i] = tz_offset;
        overlaps_inputs[i] = good_times.map((gt) => [city_times[gt[0]] - tz_offset, city_times[gt[1]] - tz_offset]);
        last_start_time = Math.max(last_start_time, overlaps_inputs[i][0][0]);
        let end_time = overlaps_inputs[i][good_times.length - 1][1];
        if (first_end_time < 0) {
            first_end_time = end_time;
        } else {
            first_end_time = Math.min(first_end_time, end_time);
        }
    }
    return [city_offsets, overlaps_inputs, last_start_time, first_end_time];
}

function computeOverlappingIntervals(overlaps_inputs, last_start_time, first_end_time) {
    console.log(overlaps_inputs);
    let interval_indices = new Object();
    for (const id in overlaps_inputs) {
        let interval_index = -1;
        for (const [interval_start, interval_end] of overlaps_inputs[id]) {
            interval_index++;
            if (last_start_time <= interval_end) {
                break;
            }
            if (last_start_time <= interval_start) {
                interval_index = -1;
                break;
            }
        }

        if (interval_index > -1) {
            interval_indices[id] = interval_index;
            continue;
        }
    }
    console.log(interval_indices);

    let feasible_intervals = [];
    for (let check_time = last_start_time; check_time < first_end_time;) {
        let last_next_start = -1, first_next_start = first_end_time;
        let interval_proposal = [check_time, first_end_time];
        for (const id in interval_indices) {
            let i = 0;
            for(i = interval_indices[id]; i < overlaps_inputs[id].length && check_time > overlaps_inputs[id][i][1]; i++);
            if (i >= overlaps_inputs[id].length || check_time < overlaps_inputs[id][i][0]) {
                // Infeasible
                interval_proposal = null;
                if (i < overlaps_inputs[id].length) {
                    last_next_start = Math.max(overlaps_inputs[id][i][0], last_next_start);
                }
            } else {
                if (interval_proposal !== null) {
                    interval_proposal[1] = Math.min(overlaps_inputs[id][i][1], interval_proposal[1]);
                }
                if (i + 1 < overlaps_inputs[id].length) {
                    first_next_start = Math.min(overlaps_inputs[id][i + 1][0], first_next_start);
                }
            }
            interval_indices[id] = i;

        }
        console.log(interval_indices);
        console.log(interval_proposal);

        if (interval_proposal !== null) {
            feasible_intervals.push(interval_proposal);
            check_time = first_next_start;
        } else if (last_next_start > -1) {
            check_time = last_next_start;
        } else {
            break;
        }
        console.log(check_time);
    }

    return feasible_intervals;
}

function updateOverlaps() {
    resetCopyButton();
    let choghadiya_data = getDateAndChoghadiyaRow();
    if (!choghadiya_data) {
        for (let i = 0; i < city_count; i++) {
            document.getElementById(`overlap-${i}-data`).innerText = "Please input a date for the overlaps.";
        }
        return;
    }

    let choghadiya_row = choghadiya_data[3];
    const good_times = computeContiguousGoodMurats(choghadiya_row);
    const [city_offsets, overlaps_inputs, last_start_time, first_end_time] = getCityOffsetsAndOverlapInputs(good_times);
    if (last_start_time < 0) {
        // No valid inputs, just exit -- getCityOffsetsAndOverlapInputs complained as needed.
        return;
    }

    const feasible_intervals = computeOverlappingIntervals(overlaps_inputs, last_start_time, first_end_time);

    for (const id in overlaps_inputs) {
        const table = document.createElement("table");
        table.border = "1";
        const heading_row = document.createElement("tr");
        let interval_count = 0;
        for (const [interval_start, interval_end] of feasible_intervals) {
            const heading = document.createElement("th");
            heading.innerText = `${utcTimeToString(interval_start + city_offsets[id])} - ${utcTimeToString(interval_end + city_offsets[id])}`;
            heading.classList.add(`overlap-interval-${interval_count}`);
            heading.addEventListener("mouseenter", makeIntervalHighlighter(interval_count, "green"));
            heading.addEventListener("mouseleave", makeIntervalHighlighter(interval_count, "white"));
            heading_row.appendChild(heading);
            interval_count++;
        }
        table.appendChild(heading_row);
        let overlap_entry = document.getElementById(`overlap-${id}-data`);
        overlap_entry.innerHTML = "";
        overlap_entry.appendChild(table);
    }
}

function cityNUpdater(n) {
    return function (also_update_overlaps) {
        let sunrise_input = document.getElementById(`city-${n}-sunrise`);
        let sunset_input = document.getElementById(`city-${n}-sunset`);
        let choghadiya_ouput = document.getElementById(`city-${n}-choghadiya`);

        if (!sunrise_input.value) {
            choghadiya_ouput.innerText = "Please enter the sunrise time.";
            return;
        }
        if (!sunset_input.value) {
            choghadiya_ouput.innerText = "Please enter the sunset time.";
            return;
        }
        let choghadiya_data = getDateAndChoghadiyaRow();
        if (!choghadiya_data) {
            choghadiya_ouput.innerText = "Please enter the date (above).";
            return;
        }
        let [year, month, day, choghadiya_row] = choghadiya_data;


        let [sunrise_hour, sunrise_minute] = sunrise_input.value.split(":").map((t) => parseInt(t));
        let [sunset_hour, sunset_minute] = sunset_input.value.split(":").map((t) => parseInt(t));

        // Use UTC to simplify timezone shenanigans.
        // Use *1 to work with epoch millis so that we don't have to deal with "+" casting to strings.
        let sunrise_date = (new Date(Date.UTC(year, month, day, sunrise_hour, sunrise_minute))) * 1;
        let sunset_date = (new Date(Date.UTC(year, month, day, sunset_hour, sunset_minute))) * 1;
        if (sunset_date < sunrise_date) {
            choghadiya_ouput.innerText = "Sunrise must come before sunset!";
            return;
        }

        let times = new Array(17);
        for (let i = 0; i < 8; i++) {
            times[i] = sunrise_date + (sunset_date - sunrise_date) / 8 * i;
        }
        let next_date_sunrise = sunrise_date + 24 * 60 * 60 * 1000;
        for (let i = 0; i < 9; i++) {
            times[i + 8] = sunset_date + (next_date_sunrise - sunset_date) / 8 * i;
        }
        city_times_map[n] = times;

        let times_strings = times.map(utcTimeToString);

        let city_table = document.createElement("table");
        city_table.border = "1";
        let times_row = document.createElement("tr");
        for (let i = 0; i < 16; i++) {
            let times_heading = document.createElement("th");
            times_heading.innerText = `${times_strings[i]} - ${times_strings[i + 1]}`;
            times_row.appendChild(times_heading);
        }
        city_table.appendChild(times_row);

        let day_index = new Date(year, month, day).getDay();
        let murat_row = document.createElement("tr");
        for (let i = 0; i < 16; i++) {
            let murat_text = document.createElement("td");
            murat_text.innerText = choghadiya_row[i];
            murat_text.classList.add((GOOD_MURATS.indexOf(choghadiya_row[i]) >= 0) ? "good-murat" : "bad-murat");
            murat_row.appendChild(murat_text);
        }
        city_table.appendChild(murat_row);

        choghadiya_ouput.innerHTML = "";
        choghadiya_ouput.appendChild(city_table);

        if (also_update_overlaps) {
            updateOverlaps();
        }
    };
}

function cityNNameUpdater(n) {
    return function (e) {
        resetCopyButton();
        document.getElementById(`overlap-${n}-name`).innerText = e.target.value || `City ${n} (please name this city)`;
    };
}

function addCity() {
    let table = document.getElementById("cities");
    let row = document.createElement("tr");

    let changeHandler = cityNUpdater(city_count);
    city_update_handlers.push(changeHandler);

    let city_name_column = document.createElement("td");
    let city_name_input = document.createElement("input");
    city_name_input.type = "text";
    city_name_input.placeholder = "Enter name...";
    city_name_input.id = `city-${city_count}-name`;
    city_name_input.addEventListener("change", cityNNameUpdater(city_count));
    city_name_column.appendChild(city_name_input);
    row.appendChild(city_name_column);

    let sunrise_column = document.createElement("td");
    let sunrise_input = document.createElement("input");
    sunrise_input.type = "time";
    sunrise_input.id = `city-${city_count}-sunrise`;
    sunrise_input.addEventListener("change", (e) => changeHandler(true));
    sunrise_column.appendChild(sunrise_input);
    row.appendChild(sunrise_column);

    let sunset_column = document.createElement("td");
    let sunset_input = document.createElement("input");
    sunset_input.type = "time";
    sunset_input.id = `city-${city_count}-sunset`;
    sunset_input.addEventListener("change", (e) => changeHandler(true));
    sunset_column.appendChild(sunset_input);
    row.appendChild(sunset_column);

    let timezone_column = document.createElement("td");
    timezone_column.appendChild(document.createTextNode("UTC + "));
    let timezone_input = document.createElement("input");
    timezone_input.type = "number";
    timezone_input.min = "-12";
    timezone_input.max = "12";
    timezone_input.step = "0.5";
    timezone_input.id = `city-${city_count}-timezone`;
    timezone_input.addEventListener("change", (e) => updateOverlaps());
    timezone_column.appendChild(timezone_input);
    row.appendChild(timezone_column);

    let choghadiya_column = document.createElement("td");
    choghadiya_column.id = `city-${city_count}-choghadiya`;
    choghadiya_column.innerText = "Enter the sunrise and sunset for this city to see its Choghadiya.";
    row.appendChild(choghadiya_column);

    table.appendChild(row);

    let overlaps_table = document.getElementById("overlaps");
    let new_overlap_row = document.createElement("tr");
    let city_name_in_overlap = document.createElement("td");
    city_name_in_overlap.id = `overlap-${city_count}-name`;
    city_name_in_overlap.innerText = `City ${city_count} (please name this city)`;
    new_overlap_row.appendChild(city_name_in_overlap);
    let city_overlaps_data = document.createElement("td");
    city_overlaps_data.id = `overlap-${city_count}-data`;
    new_overlap_row.appendChild(city_overlaps_data);
    overlaps_table.appendChild(new_overlap_row);

    city_count++;
}

document.getElementById("add-city").addEventListener("click", (e) => addCity());
document.getElementById("initial-date").addEventListener("change", (e) => {
    city_update_handlers.forEach((h) => h(false));
    updateOverlaps();
});

document.getElementById("share-button").addEventListener("click", async function (e) {
    const date_data = getDateAndChoghadiyaRow();
    let [year, month, day, data] = (date_data !== null)? date_data: [-57, 0, 1, []];
    let cities = [];
    for (let i = 0; i < city_count; i++) {
        const city_name = document.getElementById(`city-${i}-name`).value;
        const timezone = document.getElementById(`city-${i}-timezone`).value;
        cities.push({
            "name": city_name,
            "timezone": timezone
        });

        const sunrise = document.getElementById(`city-${i}-sunrise`).value;
        if (sunrise) {
            const [sunrise_hour, sunrise_minute] = sunrise.split(":").map((t) => parseInt(t));
            const sunrise_date = (new Date(Date.UTC(year, month, day, sunrise_hour, sunrise_minute))) * 1;
            cities[cities.length - 1]["sunrise"] = sunrise_date;
        }
        const sunset = document.getElementById(`city-${i}-sunset`).value;
        if (sunset) {
            const [sunset_hour, sunset_minute] = sunset.split(":").map((t) => parseInt(t));
            const sunset_date = (new Date(Date.UTC(year, month, day, sunset_hour, sunset_minute))) * 1;
            cities[cities.length - 1]["sunset"] = sunset_date;
        }

    }
    const search = JSON.stringify(cities);
    window.history.pushState(cities, "", "?" + search);
    try {
        await navigator.clipboard.writeText(document.location.href);
        e.target.innerText = "Copied!";
    } catch (err) {
        e.target.innerText = "Failed to copy -- please just copy the page URL.";
    }
});

function loadCitiesFromState(cities) {
    console.log(cities);
    if (cities.length === 0) {
        addCity();
        return;
    }

    city_times_map = new Object();
    city_update_handlers = [];
    city_count = 0;
    document.getElementById("cities").innerHTML = "";
    document.getElementById("overlaps").innerHTML = "";

    let year = 0, month = 0, day = 0;
    for (const city of cities) {
        addCity();
        if (city.name) {
            document.getElementById(`city-${city_count - 1}-name`).value = city.name;
            document.getElementById(`overlap-${city_count - 1}-name`).innerText = city.name;
        }
        if (city.timezone) {
            document.getElementById(`city-${city_count - 1}-timezone`).value = city.timezone;
        }
        if (city.sunrise) {
            const sunrise_date = new Date(city.sunrise);
            document.getElementById(`city-${city_count - 1}-sunrise`).value = `${sunrise_date.getUTCHours().toString().padStart(2, "0")}:${sunrise_date.getUTCMinutes().toString().padStart(2, "0")}`;
            year = sunrise_date.getUTCFullYear();
            month = sunrise_date.getUTCMonth();
            day = sunrise_date.getUTCDate();
        }
        if (city.sunset) {
            const sunset_date = new Date(city.sunset);
            document.getElementById(`city-${city_count - 1}-sunset`).value = `${sunset_date.getUTCHours().toString().padStart(2, "0")}:${sunset_date.getUTCMinutes().toString().padStart(2, "0")}`;
            year = sunset_date.getUTCFullYear();
            month = sunset_date.getUTCMonth();
            day = sunset_date.getUTCDate();
        }
    }

    document.getElementById("initial-date").value = `${year.toString().padStart(4, "0")}-${(month + 1).toString().padStart(2, "0")}-${day.toString().padStart(2, "0")}`;

    city_update_handlers.forEach((h) => h(false));
    updateOverlaps();
}

loadCitiesFromState(JSON.parse(decodeURI(document.location.search.slice(1) || "[]")));
window.addEventListener("popstate", (e) => {
    loadCitiesFromState(e.state);
});
        </script>
    </body>
</html>
